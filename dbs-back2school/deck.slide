Go in Enterprise Context
An introductory workshop
Tags: golang, enterprise, workshop, beginner

Stanley Nguyen
Software Engineer, Visa Inc.
hung.ngn.the@gmail.com
https://stanleynguyen.github.io
@stanley_ngn

* Golang

- compiled, concurrent, garbage-collected, statically typed
- small, opionionated
- efficient, scalable, and productive

.image images/gocloud.jpg
.caption _Gophers_building_a_cloud_system_ by [[https://www.instagram.com/reneefrench/][RenÃ©e French]]

: What is Go exactly? It's a compiled, concurrent, garbage-collected, statically typed language.
: It's small and opionionated, efficient, scalable, and productive.
: Go is not created to be a breakthrough in programming language design but rather
: an excellent tool for large software projects.

* Creators of Go
.image images/creators.png
.caption _Robert_Griesemer,_Rob_Pike,_Ken_Thompson_(left_to_right)_

: They are the veterans who conceived the Golang baby, with experience in the like
: of UNIX, Javascript V8 Engine

* Golang
.image images/googletrend.jpg
.caption _Golang_on_Google_Trend_

: Go has captured growing traction since its creation
: But the important question is whether this growth is sustainable?
: Will it make a mark in the software world, adopted and used by the majority of
: enterprises?

* Challenges in Enterprise Software Development

* Problems addressed by Go at Google
- slow builds
- uncontrolled dependencies
- developers' opionions
- maintainability (readibility, documentation, etc)
- costly updates
- difficulty in writing automated tools

: Let's start with the problems that motivates Google to dedicate resources to give birth to Go.
: In big organisations like Google, problems like ... are very common. Go was designed with specific features addressing those issues

* Dependencies in Go
- unused dependencies as compile-time error
- single object file approach
- no cyclic dependency

.image images/movinggopher.png
.caption _Moving_gopher_ by [[https://github.com/ashleymcnamara][Ashley McNamara]]

* Unused dependencies
.image images/error.png

: This guarantees the precision in Go dependency tree, ensuring no extraneous edges
: Making it compile-time error might seem to be trivial but in my opinion, it'more
: about changing the engineering team mindset. I have seen unused import statements
: in a Java program that were committed years back but no one in the team bothers
: to remove.

* Single Object File Approach

TLDR

  package A imports package B
  package B imports package C
  package A does *not* import package C

: Some of you might be wondering how this makes sense and how it would help with compilation efficiency. The idea is that when A is compiled, the compiler reads the object file for B, not its source code. That object file for B contains all the type information necessary for the compiler to execute "import B", which includes all information about C that B will need at compile time.
: Basically, the object file of B includes type information for all dependencies of B that affect its public interface. Compared to C and C++, instead of exactly one file per dependency, the compiler has multiple include of include files to handle, making it exponentially slower. Even Java compiler has some elements of this approach

* Dependencies in Go
- 50 times faster than C++ according to Go Team benchmark
.image images/compiling.png
.caption _comic_ by [[https://xkcd.com/][xkcd]]

: This approach combined with no unused nor cyclic dependency policy, Go compiler, in Rob Pike's words, "turns minutes into seconds, coffee breaks into interactive build".
: I'm so sorry that Go adoption might spell an end to our coffee breaks, but that also means we can get our work done faster and have more time to ourselves and our families.

* Go Syntax
- 25 keywords
- name before type
.code code/trivial/syntax.go /^var count/,/^type Star/
- multiple return values
.code code/trivial/syntax.go /^func FnThatReturnsMulti/
- no default argument

: Syntax in Go is design with simplicity as the first priority. Go only has 25 keywords, compared to 37 of C and 84 of C++.
: We can return multiple values from a function, which is convenient as compared to in Java, sometimes a new class is needed just for this purpose. Speaking of functions, one feature that was deliberately omitted from Go is default arguments. Defaulted arguments make it easy to patch over API design flaws, resulting in a horrible mess of arguments that are impossible to understand. The lack of default arguments force developers to define more methods which in turn makes the API clearer and more understandable. This, again, emphasizes that Go is not just another new language around the block, it's an attempt to influence engineering teams to be more productive

* Naming
Exported vs Un-exported
.code code/trivial/syntax.go /Exported/,/NotExported/

: Go took an unusual approach of defining indentifier visibility. Instead of using keywords like private or public in Java, names in Go carries the information itself - Uppercase initial letter for exported, lowercase initial letter for unexported.
: This means no more going back and forth to the declaration to discover this information. Again, simplicity for productivity.

* Concurrency
- Designed in the age of multicore and networked machines
- A variant of Communicating Sequential Processes (CSP) with first-class channels
- "Don't communicate by sharing memory, share memory by communicating"
.image images/goroutines.png

: Languages like Java, C, depsite still being popular, were designed in the age where most CPUs have only a single core. As a result, most of them treat parallelization as an afterthought.
: Go has easy, high-level CSP style built-in concurrency support. Go enables simple, safe concurrent programming with the motto ...
: We will see this in action later on during the workshops' exercises.

* Composition over Inheritance
- Go is data orientied
- interfaces in Go are just sets of methods
.code code/trivial/composition.go /START OMIT/,/END OMIT/
- composition through interface embedding
.code code/trivial/embed.go /START OMIT/,/END OMIT/

: Go uses interface to implement polymorphism. The idea of composition over inheritance is predominant in OOP, allowing system to be more flexible with loosely coupled components.
: Go went one step above languages like Java to ensure that composition is guaranteed by removing classes altogther - the one thing that, if wrongly utilised, causes eternal pain in large codebase.

* Errors
- errors in Go are just values
- deliberately simple
.image images/gopherscable.png

: Errors in Go are just values that can be returned from function, passed around as argument. This is a deliberate choice by the language designers for clarity and readibility.
: Because error handling with special control structures like try-catch-finally distorts the control flow of programs by interlacing multiple overlapping flows that interact in complex ways, it's better to be left out.
: Errors in the Go way might be more verbose but more straightforward and easier to understand.

* Tooling
- integrated within the language design
- gofmt, golint, etc
.image images/gopherswrench.jpg

: As rarely mentioned in language design discussion, tooling is as much important for a language ecosystem. And as developers, we like to wage wars over our opinions. Should we use PrettierJS or StandardJS, Airbnb or Google coding standards?
: Go put an end to this by having tooling built-in like gofmt to format source files, golint to checking code standards. Developers can then put more focus on things that matter.

* How does Go help me?
.image images/gopherlifting.gif
.caption by [[https://twitter.com/marcusolsson][Marcus Olsson]]

: That's how Go helps Google solves some of their problems. How do we relate it to our situations and check the implication of Go daoption for our organisations?
: As previously discussed, we shall all agree that Go is simple. Nonetheless, simplicity is a ridiculously powerful idea that can bring about substaintial benefits.

* Go is simple
- opionated => focus on things that matter
- straightforward, readable => easy to maintain, to onboard new hires
.image images/gophercodereview.png

: Have you ever gotten pull request comments along the line of "You can tweak this a bit so the code if more concise". There were times I spent 80% of my after-review effort just to make the code look pretty according to my reviewers' point of views. Go's opionionated design will save both of the reviewees and reviewers' time
: Go's simplicity also makes it super readable. I was struggling to get this Go present package to work with Heroku dynamic port model but I could easily dive in the source code and get it working in 15 minutes without even Googling. Imagine how big of an impact this would make on an organisations with millions of lines of codes and thousands of developers.
: There we have it, happy developers, happy working evironment with lower cost to sustain.

* Go is stable
- backward-compatibility
- commercially backed open source

.image images/ian.jpg
.caption _Ian_Lance_Taylor_at_Gopherpalooza_2018_

: One of the aspect that made Java successful in Enterprise environment is backward-compatibility. It made good use of the deprecated annotation to make sure your code always run. The team behind Go2 paid a lot of attention to this, as Ian from Go2 team mentioned in one of his talks: "We're looking at the success of C with not that many changes, and the success of Java with not that many changes, and we want stability."
: Go has also been heavily used in enterprises with the like of Google, Uber, Netflix. If those companies place the bets on Go, I believe it's here to stay.

* Go is scalable
- cross-compilation
- small memory foot-print
- small deployment size
.image images/godocker.jpg

: Cross-compilation in Go is as easy as setting an env varible for the build command. We can cross compile for different OSes like windows, linux, darwin, android and different architectures like arm, 386. You name it, Go has it.
: Unlike Java, Python, or Javascript, Go programs don't need huge and complex infrastructure like the JVM or V8 Engine, saving us hundreds of MBs in RAM, which in turns cut down cost on cloud environments.
: With the recent rises in microservices architecture where tons of Docker images have to be deployed. Imagine hundres of Node/Java images of 200MB because of the extra JVM, Node Engine compared to 20MB images with standalone Go binaries. The amount of data travelled over the network from the registry can only be measured in GB. As a result, Go applications can be deployed faster and more frequently, allowing important updates to reach production.

* @enterprises
.background images/keepcalmnusego.png

: So enterprises, please make the switch. And if you are not yet convinced, let's dive right in some hands-on exercises in our workshop portion.

* Workshop
.background images/gophers.png

: We will go through and implement basic concepts and general ideas of the language and see them in action.

* Hello World
.play code/workshop/helloworld/main.go

: As per programming's long running tradition, let's have our hello world program. This tell us about how a Go program with package declaration on top, import statements, and a main function.
: Go strings are UTF8-encoded as we can see

* Types in Go
- booleans
- numberics
- strings
- arrays
- slices
- maps
- pointers
- structs
- channels

* Basic Types
.play code/workshop/basictype/main.go /START OMIT/,/END OMIT/

: Go has basic types like booleans, integer, unsigned integer, strings
: Another point worth noting here is Go's struct

* Variable Declaration & Zero Values
.play code/workshop/declaration/main.go /START OMIT/,/END OMIT/

* OOP in Go
.background images/modelsheet.jpg

* Struct and methods
.code code/workshop/oop/person.go /START OMIT/,/END OMIT/
.play code/workshop/struct/main.go /START OMIT/,/END OMIT/

: struct type in Go is basically data structures. As I mentioned before, Go's data-orientied, struct is one of the elements that can drive Go program structure.
: structs in Go can serve as receiver for methods as well, ensuring encapsulation in OOP. Here we have "SayName" method on Person struct receiver.

* Interfaces
- set of functions to declare behaviors
- statisfied implicitly
.code code/workshop/oop/human.go /START OMIT/,/END OMIT/
.code code/workshop/oop/alien.go /START OMIT/,/END OMIT/

: interfaces in Go is as simple as a set of functions. There's no implements keywords in Go, interfaces are satisfied implicitly
: Previously we had Person struct that's a Human as it has SayName() method. Let's introduce a HumanLikeAlien struct that knows how to say its name as well

* Interfaces
.play code/workshop/interface/main.go /START OMIT/,/END OMIT/

: We can observe here both Person and Alien knows how to say their names and satisfy the criteria for being a Human, however, they said their names in different manners as per the implementation.

* Embedding
- Go's support for composition
- inner types and methods are promoted
- promoted methods can satisfy interfaces

* Embedding
.code code/workshop/oop/junior.go /START OMIT/,/END OMIT/
.code code/workshop/oop/mentor.go /START OMIT/,/END OMIT/

: Here we have a JuniorDeveloper who can code in a certain set of languages and a Mentor who can train the Junior Dev to code in more languages

* Embedding
.code code/workshop/oop/senior.go /START OMIT/,/END OMIT/
.play code/workshop/embedding/main.go /START OMIT/,/END OMIT/

: Now we have a senior dev, who, not only how to code, in a senior way of course, but is also a mentor who can train junior dev
: Let see him in action for an internal training. <Run Code> After this useful mentorship from our senior dev, the junior dev now can code in 2 new languages

* Composition Exercise
Use embedding to implement 3 structs type with one that can be a
.code code/workshop/composition/interface.go /START OMIT/,/END OMIT/
the other 2 should hold separate business and tech concerns.
The Founder struct should be able to survive a VC pitch like below
.code code/workshop/composition/pitch.go /START OMIT/,/END OMIT/

* Composition Exercise - Sample Solution
.code code/workshop/composition/types.go /START OMIT/,/END OMIT/

* Composition Exercise - Sample Solution
.play code/workshop/composition_solution/main.go
